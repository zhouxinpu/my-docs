## 运算符

### 定义

> 运算符是处理数据的基本方法，用来从现有的值得到新的值。

* 加法运算符：x + y
* 减法运算符： x - y
* 乘法运算符： x * y
* 除法运算符：x / y
* 指数运算符：x ** y
* 余数运算符：x % y
* 自增运算符：++x 或者 x++
* 自减运算符：--x 或者 x--
* 数值运算符： +x
* 负数值运算符：-x

### 加法运算符

#### 字符串的相加

> 两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。

> 一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。

> 加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。只有加法运算符会发生重载。

#### 对象的相加

> 运算子是对象，必须先转成原始类型的值，然后再相加。

**对象转成原始类型的值，规则如下。**

首先，自动调用对象的valueOf方法。如果valueOf方法直接返回一个原始类型的值，就不再调用toString方法。
```js
var obj = { p: 1 };
obj.valueOf() // { p: 1 }
```
一般来说，对象的valueOf方法总是返回对象自身，这时再自动调用对象的toString方法，将其转为字符串。
```js
var obj = { p: 1 };
obj.valueOf().toString() // "[object Object]"
```

知道这个规则，我们就可以自定义valueOf方法或toString方法，得到想要的结果

> 自定义valueOf方法
```js
var obj = {
  valueOf: function () {
    return 1;
  }
};

obj + 2 // 3
```

> 自定义toString方法
```js
var obj = {
  toString: function () {
    return 'hello';
  }
};

obj + 2 // "hello2"
```

### 余数运算符

> 余数运算符（%）返回前一个运算子被后一个运算子除，所得的余数。

**运算结果的正负号由第一个运算子的正负号决定。**

### 自增和自减运算符

> 自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。
```js
var x = 1;
++x // 2
x // 2

--x // 1
x // 1
```

**放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。**

### 比较运算符

> 比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件。

* \> 大于运算符
* < 小于运算符
* <= 小于或等于运算符
* \>= 大于或等于运算符
* == 相等运算符
* === 严格相等运算符
* != 不相等运算符
* !== 严格不相等运算符

#### 字符串的比较

> 字符串按照字典顺序进行比较。

#### 非字符串的比较

> 如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。

##### 原始类型值

> 两个运算子都是原始类型的值，则是先转成数值再比较。
```js
5 > '4' // true
// 等同于 5 > Number('4')
// 即 5 > 4

true > false // true
// 等同于 Number(true) > Number(false)
// 即 1 > 0

2 > true // true
// 等同于 2 > Number(true)
// 即 2 > 1
```
**上面代码中，字符串和布尔值都会先转成数值，再进行比较。**

**需要注意与NaN的比较。任何值（包括NaN本身）与NaN使用非相等运算符进行比较，返回的都是 false**

##### 对象
> 运算子是对象，会转为原始类型的值，再进行比较。

> 对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法。
```js
var x = [2];
x > '11' // true
// 等同于 [2].valueOf().toString() > '11'
// 即 '2' > '11'

x.valueOf = function () { return '1' };
x > '11' // false
// 等同于 [2].valueOf() > '11'
// 即 '1' > '11'
```

两个对象之间的比较也是如此。

```js
[2] > [1] // true
// 等同于 [2].valueOf().toString() > [1].valueOf().toString()
// 即 '2' > '1'

[2] > [11] // true
// 等同于 [2].valueOf().toString() > [11].valueOf().toString()
// 即 '2' > '11'

{ x: 2 } >= { x: 1 } // true
// 等同于 { x: 2 }.valueOf().toString() >= { x: 1 }.valueOf().toString()
// 即 '[object Object]' >= '[object Object]'
```

#### 严格相等运算符

> JavaScript 提供两种相等运算符：== 和 ===。

简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。

1. 两个值的类型不同，直接返回false。
2. 同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。
3. 两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。
4. undefined和null与自身严格相等。

#### 相等运算符

> 相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。

##### 原始类型的值
原始类型的值会转换成数值再进行比较。

```js
1 == true // true
// 等同于 1 === Number(true)

0 == false // true
// 等同于 0 === Number(false)

2 == true // false
// 等同于 2 === Number(true)

2 == false // false
// 等同于 2 === Number(false)

'true' == true // false
// 等同于 Number('true') === Number(true)
// 等同于 NaN === 1

'' == 0 // true
// 等同于 Number('') === 0
// 等同于 0 === 0

'' == false  // true
// 等同于 Number('') === Number(false)
// 等同于 0 === 0

'1' == true  // true
// 等同于 Number('1') === Number(true)
// 等同于 1 === 1

'\n  123  \t' == 123 // true
// 因为字符串转为数字时，省略前置和后置的空格
```

##### 对象与原始类型值比较

> 对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。 

> 先调用对象的valueOf()方法，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用toString()方法，得到字符串形式，再进行比较。
```js
// 数组与数值的比较
[1] == 1 // true

// 数组与字符串的比较
[1] == '1' // true
[1, 2] == '1,2' // true

// 对象与布尔值的比较
[1] == true // true
[2] == true // false
```

```js
const obj = {
  valueOf: function () {
    console.log('执行 valueOf()');
    return obj;
  },
  toString: function () {
    console.log('执行 toString()');
    return 'foo';
  }
};

obj == 'foo'
// 执行 valueOf()
// 执行 toString()
// true
```

##### undefined 和 null

> undefined和null只有与自身比较，或者互相比较时，才会返回true；与其他类型的值比较时，结果都为false。

##### 相等运算符的缺点

> 相等运算符隐藏的类型转换，会带来一些违反直觉的结果。
```js
0 == ''             // true
0 == '0'            // true

2 == true           // false
2 == false          // false

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true

' \t\r\n ' == 0     // true
```

#### 不相等运算符

> 相等运算符有一个对应的“不相等运算符”（!=），它的算法就是先求相等运算符的结果，然后返回相反值。
```js
1 != '1' // false

// 等同于
!(1 == '1')
```


### 布尔运算符

> 布尔运算符用于将表达式转为布尔值，一共包含四个运算符。

* 取反运算符：!
* 且运算符：&&
* 或运算符：||
* 三元运算符：?:

#### 取反运算符

> 以下六个值取反后为true，其他值都为false。

* undefined
* null
* false
* 0
* NaN
* 空字符串（''）

#### 且运算符（&&）

> 如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。

#### 或运算符（||）

> 或运算符（||）也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。

#### 三元条件运算符（?:）

> 三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。


### 二进制运算符

待整理